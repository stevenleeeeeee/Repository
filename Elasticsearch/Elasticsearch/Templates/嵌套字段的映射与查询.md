#### 映射
```python
PUT /my_index
{
  "mappings": {
    "blogpost": {
      "properties": {
        "comments": {
          "type": "nested",             # 设置字段为 nested 很简单: 只需要将字段类型 object 替换为 nested 即可, nested字段类型的设置参数与object相同
          "properties": {               # 至此所有 comments 对象会被索引在独立的嵌套文档
            "name":    { "type": "string"  },
            "comment": { "type": "string"  },
            "age":     { "type": "short"   },
            "stars":   { "type": "short"   },
            "date":    { "type": "date"    }
          }
        }
      }
    }
  }
}

# nested字段可以包含其他的nested字段
```
#### 查询
```python
# 由于嵌套对象被索引在独立隐藏的文档中，因而无法直接查询。 相应地我们必须使用 nested 查询去获取它：

GET /my_index/blogpost/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": "eggs"             # title子句是查询根文档的
          }
        },
        {
          "nested": {                   
            "path": "comments",         # nested 子句作用于嵌套字段 comments , 即上面映射中定义的嵌套对象: "comments" 注意: 在此查询中既不能查询根文档字段也不能查询其他嵌套文档
            "query": {
              "bool": {
                "must": [ 
                  {
                    "match": {
                      "comments.name": "john"           # comments.name 和 comments.age 子句操作在同一个嵌套文档中
                    }
                  },
                  {
                    "match": {
                      "comments.age": 28                # ...
                    }
                  }
                ]
              }
            }
          }
        }
      ]
}}}

# nested字段可以包含其他的nested字段。同样地nested查询也可以包含其他的nested查询。而嵌套的层次会按照你所期待的被应用
```

#### 使用嵌套字段排序
```python
# 尽管嵌套字段的值存储于独立的嵌套文档中，但依然有方法按照嵌套字段的值排序
# 让我们添加一个记录，以使得结果更有意思：
PUT /my_index/blogpost/2
{
  "title": "Investment secrets",
  "body":  "What they don't tell you ...",
  "tags":  [ "shares", "equities" ],
  "comments": [
    {
      "name":    "Mary Brown",
      "comment": "Lies, lies, lies",
      "age":     42,
      "stars":   1,
      "date":    "2014-10-18"
    },
    {
      "name":    "John Smith",
      "comment": "You're making it up!",
      "age":     28,
      "stars":   2,
      "date":    "2014-10-16"
    }
  ]
}


# 假如要查询在10月份收到评论的博客文章，并且按照 stars 数的最小值来由小到大排序，那么查询语句如下：
GET /_search
{
  "query": {
    "nested": {                 # 此处的 nested 查询将结果限定为在10月份收到过评论的博客文章
      "path": "comments",
      "filter": {
        "range": {
          "comments.date": {
            "gte": "2014-10-01",
            "lt":  "2014-11-01"
          }
        }
      }
    }
  },
  "sort": {
    "comments.stars": {         # 结果按照匹配的评论中 comment.stars 字段的最小值 (min) 来由小到大 (asc) 排序
      "order": "asc",   
      "mode":  "min",   
      "nested_path": "comments", 
      "nested_filter": {        # 排序子句中的 nested_path 和 nested_filter 和 query 子句中的 nested 查询相同，原因在下面有解释
        "range": {
          "comments.date": {
            "gte": "2014-10-01",
            "lt":  "2014-11-01"
          }
        }
      }
    }
  }
}

# 为什么要用 nested_path 和 nested_filter 重复查询条件:
# 原因在于排序发生在查询执行之后。 查询条件限定了在10月份收到评论的博客文档，但返回的是博客文档。
# 如果我们不在排序子句中加入 nested_filter， 那么我们对博客文档的排序将基于博客文档的所有评论，而不是仅仅在10月份接收到的评论
```