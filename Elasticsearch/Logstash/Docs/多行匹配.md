```bash
#不要在logstash的filter plugin中配置multiline
#如果在filter plugin中配multiline的话，logstash的workers会强制设置为1（即使设置为其他值也没用）
#这样会导致logstash处理效率下降。解决办法就是将多行匹配配置到input plugin中!

input {
  stdin {
    codec => multiline {
      #patterns_dir => #...
      pattern => "^# User@Host:"    #正则匹配
      negate => true                #设置true是向前匹配，设置false向后匹配，默认 FALSE
      what => previous              #处理行为，只能为previous/next，为previous时代表匹配此模式的行属于前面的事件内容
      #charset =>     #字符编码
      #max_bytes =>   #最大的字节数
      #max_lines =>   #最大的行数
      #multiline_tag =>   #设置一个事件标签，默认是multiline

      #上面配置表明如果不以 "# User@Host:" 开头的行都属于前面的事件内容
    }
  }
}

output {
  elasticsearch { hosts => ["localhost:9200"] }
  stdout { codec => rubydebug }
}
```
```
#### filter { grok{ xxx } } 中对多行匹配的处理
```bash
# 如果日志有多种可能的格式，单一的正则匹配比较困难，其实可以传递多个正则来匹配同一个字段
# 匹配时将会按照这个定义次序依次尝试匹配，到匹配成功为止:

filter {
    match => [
      "message", "(?<request_time>\d+(?:\.\d+)?)",    #自定义正则
      "message", "%{SYSLOGBASE} %{DATA:message}",     #使用自带的正则标记
      "message", "(?m)%{WORD}"                        #跨行匹配字符串, (?m) 表示多行匹配!
    ]
}
```